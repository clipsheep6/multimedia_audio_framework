diff a/services/audio_policy/server/src/audio_policy_server.cpp b/services/audio_policy/server/src/audio_policy_server.cpp	(rejected hunks)
@@ -553,13 +560,13 @@ int32_t AudioPolicyServer::SetSingleStreamMute(AudioStreamType streamType, bool
     }
 
     int result = mPolicyService.SetStreamMute(streamType, mute);
-    for (auto it = volumeChangeCbsMap_.begin(); it != volumeChangeCbsMap_.end(); ++it) {
-        std::shared_ptr<VolumeKeyEventCallback> volumeChangeCb = it->second;
-        if (volumeChangeCb == nullptr) {
-            AUDIO_ERR_LOG("volumeChangeCb: nullptr for client : %{public}d", it->first);
+    for (auto it = volumeKeyEventPolicyProxyCBMap_.begin(); it != volumeKeyEventPolicyProxyCBMap_.end(); ++it) {
+        std::shared_ptr<AudioPolicyClientProxy> volumeChangeCbProxy = it->second;
+        if (volumeChangeCbProxy == nullptr) {
+            AUDIO_ERR_LOG("volumeChangeCbProxy: nullptr for client : %{public}d", it->first);
             continue;
         }
-        AUDIO_DEBUG_LOG("SetStreamMute trigger volumeChangeCb clientPid: %{public}d, type: %{public}d",
+        AUDIO_DEBUG_LOG("SetStreamMute trigger volumeChangeCbProxy clientPid: %{public}d, type: %{public}d",
             it->first, streamType);
         VolumeEvent volumeEvent;
         volumeEvent.volumeType = streamType;
@@ -613,21 +620,21 @@ int32_t AudioPolicyServer::SetSingleStreamVolume(AudioStreamType streamType, int
     }
 
     int ret = mPolicyService.SetSystemVolumeLevel(streamType, volumeLevel, isUpdateUi);
-    for (auto it = volumeChangeCbsMap_.begin(); it != volumeChangeCbsMap_.end(); ++it) {
-        std::shared_ptr<VolumeKeyEventCallback> volumeChangeCb = it->second;
-        if (volumeChangeCb == nullptr) {
-            AUDIO_ERR_LOG("volumeChangeCb: nullptr for client : %{public}d", it->first);
+    for (auto it = volumeKeyEventPolicyProxyCBMap_.begin(); it != volumeKeyEventPolicyProxyCBMap_.end(); ++it) {
+        std::shared_ptr<AudioPolicyClientProxy> volumeChangeCbProxy = it->second;
+        if (volumeChangeCbProxy == nullptr) {
+            AUDIO_ERR_LOG("volumeChangeCbProxy: nullptr for client : %{public}d", it->first);
             continue;
         }
 
-        AUDIO_DEBUG_LOG("SetSystemVolumeLevelInternal trigger volumeChangeCb clientPid : %{public}d", it->first);
+        AUDIO_DEBUG_LOG("SetSystemVolumeLevelInternal trigger volumeChangeCbProxy clientPid : %{public}d", it->first);
         VolumeEvent volumeEvent;
         volumeEvent.volumeType = streamType;
         volumeEvent.volume = GetSystemVolumeLevel(streamType);
         volumeEvent.updateUi = isUpdateUi;
         volumeEvent.volumeGroupId = 0;
         volumeEvent.networkId = LOCAL_NETWORK_ID;
-        volumeChangeCb->OnVolumeKeyEvent(volumeEvent);
+        volumeChangeCbProxy->OnVolumeKeyEvent(volumeEvent);
     }
 
     return ret;
@@ -864,15 +871,15 @@ int32_t AudioPolicyServer::SetMicrophoneMuteCommon(bool isMute, API_VERSION api_
     bool isMicrophoneMute = IsMicrophoneMute(api_v);
     int32_t ret = mPolicyService.SetMicrophoneMute(isMute);
     if (ret == SUCCESS && isMicrophoneMute != isMute) {
-        for (auto it = micStateChangeCbsMap_.begin(); it != micStateChangeCbsMap_.end(); ++it) {
-            std::shared_ptr<AudioManagerMicStateChangeCallback> micStateChangeListenerCb = it->second;
-            if (micStateChangeListenerCb == nullptr) {
+        for (auto it = micStateChangeProxyCbsMap_.begin(); it != micStateChangeProxyCbsMap_.end(); ++it) {
+            std::shared_ptr<AudioPolicyClientProxy> micStateChangeListenerProxyCb = it->second;
+            if (micStateChangeListenerProxyCb == nullptr) {
                 AUDIO_ERR_LOG("callback is nullptr for client %{public}d", it->first);
                 continue;
             }
             MicStateChangeEvent micStateChangeEvent;
             micStateChangeEvent.mute = isMute;
-            micStateChangeListenerCb->OnMicStateUpdated(micStateChangeEvent);
+            micStateChangeListenerProxyCb->OnMicStateUpdated(micStateChangeEvent);
         }
     }
     return ret;
@@ -934,69 +941,86 @@ AudioScene AudioPolicyServer::GetAudioScene()
     return mPolicyService.GetAudioScene(hasSystemPermission);
 }
 
-int32_t AudioPolicyServer::SetRingerModeCallback(const int32_t /* clientId */,
-    const sptr<IRemoteObject> &object, API_VERSION api_v)
+int32_t AudioPolicyServer::RegisterRingerModeCallbackClient(const sptr<IRemoteObject> &object, const int32_t code,
+        API_VERSION api_v)
 {
-    std::lock_guard<std::mutex> lock(ringerModeMutex_);
+    //std::lock_guard<std::mutex> lock(ringerModeMutex_);
 
     if (api_v == API_8 && !PermissionUtil::VerifySystemPermission()) {
-        AUDIO_ERR_LOG("SetRingerModeCallback: No system permission");
+        AUDIO_ERR_LOG("RegisterRingerModeCallbackClient: No system permission");
         return ERR_PERMISSION_DENIED;
     }
-    CHECK_AND_RETURN_RET_LOG(object != nullptr, ERR_INVALID_PARAM, "SetRingerModeCallback object is nullptr");
-
-    sptr<IStandardRingerModeUpdateListener> listener = iface_cast<IStandardRingerModeUpdateListener>(object);
-    CHECK_AND_RETURN_RET_LOG(listener != nullptr, ERR_INVALID_PARAM, "SetRingerModeCallback object cast failed");
-
-    std::shared_ptr<AudioRingerModeCallback> callback = std::make_shared<AudioRingerModeListenerCallback>(listener);
-    CHECK_AND_RETURN_RET_LOG(callback != nullptr, ERR_INVALID_PARAM, "SetRingerModeCallback failed to  create cb obj");
-
+    CHECK_AND_RETURN_RET_LOG(object != nullptr, ERR_INVALID_PARAM, "RegisterRingerModeCallback object is nullptr");
     int32_t clientPid = IPCSkeleton::GetCallingPid();
-    ringerModeCbsMap_[clientPid] = callback;
-
-    return SUCCESS;
+    std::shared_ptr<AudioPolicyClientProxy> proxy = GetAudioPolicyClientProxy(clientPid, object,
+        ringerModeProxyCbsMap_);
+    if (proxy == nullptr) {
+        return ERR_INVALID_OPERATION;
+    }
+    return proxy->RegisterPolicyCallbackClient(object, code);
 }
 
-int32_t AudioPolicyServer::UnsetRingerModeCallback(const int32_t /* clientId */)
+int32_t AudioPolicyServer::UnregisterRingerModeCallbackClient(const int32_t code)
 {
-    std::lock_guard<std::mutex> lock(ringerModeMutex_);
-
     int32_t clientPid = IPCSkeleton::GetCallingPid();
-    if (ringerModeCbsMap_.erase(clientPid) == 0) {
-        AUDIO_ERR_LOG("UnsetRingerModeCallback Cb does not exist for client %{public}d", clientPid);
+    std::shared_ptr<AudioPolicyClientProxy> proxy = GetAudioPolicyClientProxy(clientPid, nullptr,
+    ringerModeProxyCbsMap_);
+    if (proxy == nullptr) {
+        return ERR_INVALID_OPERATION;
+    }
+    proxy->UnregisterPolicyCallbackClient(code);
+
+
+    std::lock_guard<std::mutex> lock(ringerModeMutex_);
+    if (ringerModeProxyCbsMap_.erase(clientPid) == 0) {
+        AUDIO_ERR_LOG("UnregisterRingerModeCallbackClient does not exist for client %{public}d", clientPid);
         return ERR_INVALID_OPERATION;
     }
 
     return SUCCESS;
 }
 
-int32_t AudioPolicyServer::SetMicStateChangeCallback(const int32_t /* clientId */, const sptr<IRemoteObject> &object)
+int32_t AudioPolicyServer::RegisterMicStateChangeCallbackClient(const sptr<IRemoteObject> &object, const int32_t code)
 {
     std::lock_guard<std::mutex> lock(micStateChangeMutex_);
 
     CHECK_AND_RETURN_RET_LOG(object != nullptr, ERR_INVALID_PARAM,
         "SetMicStateChangeCallback set listener object is nullptr");
+    CHECK_AND_RETURN_RET_LOG(object != nullptr, ERR_INVALID_PARAM, "RegisterMicStateChangeCallback object is nullptr");
+    int32_t clientPid = IPCSkeleton::GetCallingPid();
+    std::shared_ptr<AudioPolicyClientProxy> proxy = GetAudioPolicyClientProxy(clientPid, object,
+        micStateChangeProxyCbsMap_);
+    if (proxy == nullptr) {
+        return ERR_INVALID_OPERATION;
+    }
+    return proxy->RegisterPolicyCallbackClient(object, code);
+}
 
-    sptr<IStandardAudioRoutingManagerListener> listener = iface_cast<IStandardAudioRoutingManagerListener>(object);
-    CHECK_AND_RETURN_RET_LOG(listener != nullptr, ERR_INVALID_PARAM,
-        "SetMicStateChangeCallback listener obj cast failed");
+int32_t AudioPolicyServer::UnregisterMicStateChangeCallbackClient(const int32_t code)
+{
+    int32_t clientPid = IPCSkeleton::GetCallingPid();
+    std::shared_ptr<AudioPolicyClientProxy> proxy = GetAudioPolicyClientProxy(clientPid, nullptr,
+    micStateChangeProxyCbsMap_);
+    if (proxy == nullptr) {
+        return ERR_INVALID_OPERATION;
+    }
+    proxy->UnregisterPolicyCallbackClient(code);
 
-    std::shared_ptr<AudioManagerMicStateChangeCallback> callback =
-        std::make_shared<AudioRoutingManagerListenerCallback>(listener);
-    CHECK_AND_RETURN_RET_LOG(callback != nullptr, ERR_INVALID_PARAM,
-        "SetMicStateChangeCallback failed to create cb obj");
 
-    int32_t clientPid = IPCSkeleton::GetCallingPid();
-    micStateChangeCbsMap_[clientPid] = callback;
+    std::lock_guard<std::mutex> lock(ringerModeMutex_);
+    if (micStateChangeProxyCbsMap_.erase(clientPid) == 0) {
+        AUDIO_ERR_LOG("UnregisterMicStateChangeCallbackClient does not exist for client %{public}d", clientPid);
+        return ERR_INVALID_OPERATION;
+    }
 
     return SUCCESS;
 }
 
-int32_t AudioPolicyServer::SetDeviceChangeCallback(const int32_t /* clientId */, const DeviceFlag flag,
-    const sptr<IRemoteObject> &object)
+int32_t AudioPolicyServer::RegisterDeviceChangeCallbackClient(const sptr<IRemoteObject> &object, const uint32_t code,
+    const DeviceFlag flag)
 {
     CHECK_AND_RETURN_RET_LOG(object != nullptr, ERR_INVALID_PARAM,
-        "SetDeviceChangeCallback set listener object is nullptr");
+        "RegisterDeviceChangeCallbackClient set listener object is nullptr");
     bool hasSystemPermission = PermissionUtil::VerifySystemPermission();
     switch (flag) {
         case NONE_DEVICES_FLAG:
@@ -1015,48 +1039,51 @@ int32_t AudioPolicyServer::SetDeviceChangeCallback(const int32_t /* clientId */,
 
     int32_t clientPid = IPCSkeleton::GetCallingPid();
     bool hasBTPermission = VerifyPermission(USE_BLUETOOTH_PERMISSION);
-    return mPolicyService.SetDeviceChangeCallback(clientPid, flag, object, hasBTPermission);
+    return mPolicyService.RegisterDeviceChangeCallbackClient(object, code, flag, clientPid, hasBTPermission);
 }
 
-int32_t AudioPolicyServer::UnsetDeviceChangeCallback(const int32_t /* clientId */, DeviceFlag flag)
+int32_t AudioPolicyServer::UnregisterDeviceChangeCallbackClient(const uint32_t code, DeviceFlag flag)
 {
     int32_t clientPid = IPCSkeleton::GetCallingPid();
-    return mPolicyService.UnsetDeviceChangeCallback(clientPid, flag);
+    bool hasBTPermission = VerifyPermission(USE_BLUETOOTH_PERMISSION);
+    return mPolicyService.UnregisterDeviceChangeCallbackClient(code, flag, clientPid, hasBTPermission);
 }
 
-int32_t AudioPolicyServer::SetPreferredOutputDeviceChangeCallback(const int32_t /* clientId */,
-    const sptr<IRemoteObject> &object)
+int32_t AudioPolicyServer::RegisterPreferredOutputDeviceChangeCbClient(const sptr<IRemoteObject> &object,
+    const int32_t code)
 {
     CHECK_AND_RETURN_RET_LOG(object != nullptr, ERR_INVALID_PARAM, "object is nullptr");
     int32_t clientPid = IPCSkeleton::GetCallingPid();
     bool hasBTPermission = VerifyPermission(USE_BLUETOOTH_PERMISSION);
-    return mPolicyService.SetPreferredOutputDeviceChangeCallback(clientPid, object, hasBTPermission);
+    return mPolicyService.RegisterPreferredOutputDeviceChangeCbClient(clientPid, object, hasBTPermission, code);
 }
 
-int32_t AudioPolicyServer::SetPreferredInputDeviceChangeCallback(const sptr<IRemoteObject> &object)
+int32_t AudioPolicyServer::RegisterPreferredInputDeviceChangeCbClient(const sptr<IRemoteObject> &object,
+    const int32_t code)
 {
     CHECK_AND_RETURN_RET_LOG(object != nullptr, ERR_INVALID_PARAM, "object is nullptr");
     int32_t clientPid = IPCSkeleton::GetCallingPid();
     bool hasBTPermission = VerifyPermission(USE_BLUETOOTH_PERMISSION);
-    return mPolicyService.SetPreferredInputDeviceChangeCallback(clientPid, object, hasBTPermission);
+    return mPolicyService.RegisterPreferredInputDeviceChangeCbClient(clientPid, object, hasBTPermission, code);
 }
 
-int32_t AudioPolicyServer::UnsetPreferredOutputDeviceChangeCallback(const int32_t /* clientId */)
+int32_t AudioPolicyServer::UnRegisterPreferredOutputDeviceChangeCbClient(const int32_t code)
 {
     int32_t clientPid = IPCSkeleton::GetCallingPid();
-    return mPolicyService.UnsetPreferredOutputDeviceChangeCallback(clientPid);
+    bool hasBTPermission = VerifyPermission(USE_BLUETOOTH_PERMISSION);
+    return mPolicyService.UnRegisterPreferredOutputDeviceChangeCbClient(clientPid, hasBTPermission, code);
 }
 
-int32_t AudioPolicyServer::UnsetPreferredInputDeviceChangeCallback()
+int32_t AudioPolicyServer::UnregisterPreferredInputDeviceChangeCbClient(const int32_t code)
 {
     int32_t clientPid = IPCSkeleton::GetCallingPid();
-    return mPolicyService.UnsetPreferredInputDeviceChangeCallback(clientPid);
+    bool hasBTPermission = VerifyPermission(USE_BLUETOOTH_PERMISSION);
+    return mPolicyService.UnregisterPreferredInputDeviceChangeCbClient(clientPid, hasBTPermission, code);
 }
 
-int32_t AudioPolicyServer::SetAudioInterruptCallback(const uint32_t sessionID, const sptr<IRemoteObject> &object)
+int32_t AudioPolicyServer::RegisterAudioInterruptCallbackClient(const sptr<IRemoteObject> &object,
+    const uint32_t sessionID, const uint32_t code)
 {
-    std::lock_guard<std::mutex> lock(interruptMutex_);
-
     auto callerUid = IPCSkeleton::GetCallingUid();
     if (!mPolicyService.IsSessionIdValid(callerUid, sessionID)) {
         AUDIO_ERR_LOG("SetAudioInterruptCallback for sessionID %{public}d, id is invalid", sessionID);
@@ -1284,7 +1312,8 @@ int32_t AudioPolicyServer::ProcessFocusEntry(const AudioInterrupt &incomingInter
     auto focusMap = mPolicyService.GetAudioFocusMap();
     AudioFocuState incomingState = ACTIVE;
     AudioFocusType incomingFocusType = incomingInterrupt.audioFocusType;
-    std::shared_ptr<AudioInterruptCallback> policyListenerCb = interruptCbsMap_[incomingInterrupt.sessionID];
+    std::shared_ptr<AudioPolicyClientProxy> policyListenerCb =
+	    audioInterruptPolicyProxyCBMap_[incomingInterrupt.sessionID];
     InterruptEventInternal interruptEvent {INTERRUPT_TYPE_BEGIN, INTERRUPT_FORCE, INTERRUPT_HINT_NONE, 1.0f};
     for (auto iterActive = audioFocusInfoList_.begin(); iterActive != audioFocusInfoList_.end(); ++iterActive) {
         if (IsSameAppInShareMode(incomingInterrupt, iterActive->first)) {
@@ -1612,13 +1641,15 @@ void AudioPolicyServer::ProcessSessionRemoved(const uint32_t sessionID)
         AUDIO_INFO_LOG("Removed SessionID: %{public}u is present in audioFocusInfoList_", removedSessionID);
 
         (void)DeactivateAudioInterrupt(removedInterrupt);
-        (void)UnsetAudioInterruptCallback(removedSessionID);
+        (void)UnRegisterAudioInterruptCallbackClient(removedSessionID,
+            static_cast<uint32_t>(AudioPolicyClientCode::ON_INTERRUPT));
         return;
     }
 
     // Though it is not present in the owners list, check and clear its entry from callback map
     lock.unlock();
-    (void)UnsetAudioInterruptCallback(removedSessionID);
+    (void)UnRegisterAudioInterruptCallbackClient(removedSessionID,
+        static_cast<uint32_t>(AudioPolicyClientCode::ON_INTERRUPT));
 }
 
 void AudioPolicyServer::OnPlaybackCapturerStop()
@@ -2529,21 +2564,21 @@ int32_t AudioPolicyServer::SetA2dpDeviceVolume(const std::string &macAddress, co
     }
     int32_t ret = mPolicyService.SetA2dpDeviceVolume(macAddress, volume);
     if (ret == SUCCESS) {
-        for (auto it = volumeChangeCbsMap_.begin(); it != volumeChangeCbsMap_.end(); ++it) {
-            std::shared_ptr<VolumeKeyEventCallback> volumeChangeCb = it->second;
-            if (volumeChangeCb == nullptr) {
-                AUDIO_ERR_LOG("volumeChangeCb: nullptr for client : %{public}d", it->first);
+        for (auto it = volumeKeyEventPolicyProxyCBMap_.begin(); it != volumeKeyEventPolicyProxyCBMap_.end(); ++it) {
+            std::shared_ptr<AudioPolicyClientProxy> proxy = it->second;
+            if (proxy == nullptr) {
+                AUDIO_ERR_LOG("proxy: nullptr for client : %{public}d", it->first);
                 continue;
             }
 
-            AUDIO_DEBUG_LOG("SetA2dpDeviceVolume trigger volumeChangeCb clientPid : %{public}d", it->first);
+            AUDIO_DEBUG_LOG("SetA2dpDeviceVolume trigger proxy clientPid : %{public}d", it->first);
             VolumeEvent volumeEvent;
             volumeEvent.volumeType = STREAM_MUSIC;
             volumeEvent.volume = volume;
             volumeEvent.updateUi = updateUi;
             volumeEvent.volumeGroupId = 0;
             volumeEvent.networkId = LOCAL_NETWORK_ID;
-            volumeChangeCb->OnVolumeKeyEvent(volumeEvent);
+            proxy->OnVolumeKeyEvent(volumeEvent);
         }
     }
     return ret;
