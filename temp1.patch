diff --git a/frameworks/native/hdiadapter/sink/common/i_audio_renderer_sink.cpp b/frameworks/native/hdiadapter/sink/common/i_audio_renderer_sink.cpp
index 4272b493..93b8d300 100644
--- a/frameworks/native/hdiadapter/sink/common/i_audio_renderer_sink.cpp
+++ b/frameworks/native/hdiadapter/sink/common/i_audio_renderer_sink.cpp
@@ -115,7 +115,7 @@ int32_t IAudioRendererSinkInit(struct RendererSinkAdapter *adapter, const SinkAt
     iAttr.filePath = attr->filePath;
     iAttr.deviceNetworkId = attr->deviceNetworkId;
     iAttr.deviceType = attr->deviceType;
-    iAttr.channelLayout = 3;    // 3 stereo
+    iAttr.channelLayout = attr->channelLayout;
 
     return audioRendererSink->Init(iAttr);
 }
diff --git a/frameworks/native/hdiadapter/sink/fast/fast_audio_renderer_sink.cpp b/frameworks/native/hdiadapter/sink/fast/fast_audio_renderer_sink.cpp
index 320e0000..a1d9c189 100644
--- a/frameworks/native/hdiadapter/sink/fast/fast_audio_renderer_sink.cpp
+++ b/frameworks/native/hdiadapter/sink/fast/fast_audio_renderer_sink.cpp
@@ -404,6 +404,11 @@ int32_t FastAudioRendererSinkInner::CreateRender(const struct AudioPort &renderP
     InitAttrs(param);
     param.sampleRate = attr_.sampleRate;
     param.channelCount = attr_.channel;
+    if (param.channelCount == MONO) {
+        param.channelLayout = CH_LAYOUT_MONO;
+    } else if (param.channelCount == STEREO) {
+        param.channelLayout = CH_LAYOUT_STEREO;
+    }
     param.format = ConvertToHdiFormat(attr_.format);
     param.frameSize = PcmFormatToBits(attr_.format) * param.channelCount / PCM_8_BIT;
     param.startThreshold = DEEP_BUFFER_RENDER_PERIOD_SIZE / (param.frameSize); // not passed in hdi
diff --git a/frameworks/native/hdiadapter/sink/multichannel/multichannel_audio_renderer_sink.cpp b/frameworks/native/hdiadapter/sink/multichannel/multichannel_audio_renderer_sink.cpp
index ced367e9..4c3fe412 100644
--- a/frameworks/native/hdiadapter/sink/multichannel/multichannel_audio_renderer_sink.cpp
+++ b/frameworks/native/hdiadapter/sink/multichannel/multichannel_audio_renderer_sink.cpp
@@ -43,7 +43,7 @@ namespace {
 const int32_t HALF_FACTOR = 2;
 const int32_t MAX_AUDIO_ADAPTER_NUM = 5;
 const float DEFAULT_VOLUME_LEVEL = 1.0f;
-const uint32_t AUDIO_CHANNELCOUNT = 2;
+// const uint32_t AUDIO_CHANNELCOUNT = 2;
 const uint32_t AUDIO_SAMPLE_RATE_48K = 48000;
 const uint32_t DEEP_BUFFER_RENDER_PERIOD_SIZE = 4096;
 const uint32_t INT_32_MAX = 0x7fffffff;
@@ -52,22 +52,22 @@ const uint32_t PCM_16_BIT = 16;
 const uint32_t PCM_24_BIT = 24;
 const uint32_t PCM_32_BIT = 32;
 const uint32_t MULTICHANNEL_OUTPUT_STREAM_ID = 61; // 13 + 6 * 8
-const uint32_t STEREO_CHANNEL_COUNT = 2;
-
-const uint32_t MULTI_CHANNEL_THREE = 3;
-const uint32_t MULTI_CHANNEL_FOUR = 4;
-const uint32_t MULTI_CHANNEL_FIVE = 5;
-const uint32_t MULTI_CHANNEL_SIX = 6;
-const uint32_t MULTI_CHANNEL_SEVEN = 7;
-const uint32_t MULTI_CHANNEL_EIGHT = 8;
-const uint32_t MULTI_CHANNEL_TEN = 10;
-const uint64_t AUDIO_MULTICHANNEL_OUT_2POINT1 = 11;
-const uint64_t AUDIO_MULTICHANNEL_OUT_QUAD = 51;
-const uint64_t AUDIO_MULTICHANNEL_OUT_3POINT0POINT2 = 206158430215;
-const uint64_t AUDIO_MULTICHANNEL_OUT_5POINT1 = 1551;
-const uint64_t AUDIO_MULTICHANNEL_OUT_6POINT1 = 1807;
-const uint64_t AUDIO_MULTICHANNEL_OUT_7POINT1 = 1599;
-const uint64_t AUDIO_MULTICHANNEL_OUT_7POINT1POINT2 = 206158431807;
+// const uint32_t STEREO_CHANNEL_COUNT = 2;
+
+// const uint32_t MULTI_CHANNEL_THREE = 3;
+// const uint32_t MULTI_CHANNEL_FOUR = 4;
+// const uint32_t MULTI_CHANNEL_FIVE = 5;
+// const uint32_t MULTI_CHANNEL_SIX = 6;
+// const uint32_t MULTI_CHANNEL_SEVEN = 7;
+// const uint32_t MULTI_CHANNEL_EIGHT = 8;
+// const uint32_t MULTI_CHANNEL_TEN = 10;
+// const uint64_t AUDIO_MULTICHANNEL_OUT_2POINT1 = 11;
+// const uint64_t AUDIO_MULTICHANNEL_OUT_QUAD = 51;
+// const uint64_t AUDIO_MULTICHANNEL_OUT_3POINT0POINT2 = 206158430215;
+// const uint64_t AUDIO_MULTICHANNEL_OUT_5POINT1 = 1551;
+// const uint64_t AUDIO_MULTICHANNEL_OUT_6POINT1 = 1807;
+// const uint64_t AUDIO_MULTICHANNEL_OUT_7POINT1 = 1599;
+// const uint64_t AUDIO_MULTICHANNEL_OUT_7POINT1POINT2 = 206158431807;
 #ifdef FEATURE_POWER_MANAGER
 constexpr int32_t RUNNINGLOCK_LOCK_TIMEOUTMS_LASTING = -1;
 #endif
@@ -382,7 +382,7 @@ void MultiChannelRendererSinkInner::DeInit()
 void InitAttrs(struct AudioSampleAttributes &attrs)
 {
     /* Initialization of audio parameters for playback */
-    attrs.channelCount = AUDIO_CHANNELCOUNT;
+    attrs.channelCount = CHANNEL_3;
     attrs.sampleRate = AUDIO_SAMPLE_RATE_48K;
     attrs.interleaved = true;
     attrs.streamId = MULTICHANNEL_OUTPUT_STREAM_ID;
@@ -455,32 +455,33 @@ int32_t MultiChannelRendererSinkInner::CreateRender(const struct AudioPort &rend
     InitAttrs(param);
     param.sampleRate = attr_.sampleRate;
     param.channelCount = attr_.channel;
-    switch (attr_.channel) {
-        case MULTI_CHANNEL_THREE:
-            param.channelLayout = AUDIO_MULTICHANNEL_OUT_2POINT1;
-            break;
-        case MULTI_CHANNEL_FOUR:
-            param.channelLayout = AUDIO_MULTICHANNEL_OUT_QUAD;
-            break;
-        case MULTI_CHANNEL_FIVE:
-            param.channelLayout = AUDIO_MULTICHANNEL_OUT_3POINT0POINT2;
-            break;
-        case MULTI_CHANNEL_SIX:
-            param.channelLayout = AUDIO_MULTICHANNEL_OUT_5POINT1;
-            break;
-        case MULTI_CHANNEL_SEVEN:
-            param.channelLayout = AUDIO_MULTICHANNEL_OUT_6POINT1;
-            break;
-        case MULTI_CHANNEL_EIGHT:
-            param.channelLayout = AUDIO_MULTICHANNEL_OUT_7POINT1;
-            break;
-        case MULTI_CHANNEL_TEN:
-            param.channelLayout = AUDIO_MULTICHANNEL_OUT_7POINT1POINT2;
-            break;
-        default:
-            AUDIO_ERR_LOG("Unsupported channel");
-            break;
-    }
+    // switch (attr_.channel) {
+    //     case MULTI_CHANNEL_THREE:
+    //         param.channelLayout = AUDIO_MULTICHANNEL_OUT_2POINT1;
+    //         break;
+    //     case MULTI_CHANNEL_FOUR:
+    //         param.channelLayout = AUDIO_MULTICHANNEL_OUT_QUAD;
+    //         break;
+    //     case MULTI_CHANNEL_FIVE:
+    //         param.channelLayout = AUDIO_MULTICHANNEL_OUT_3POINT0POINT2;
+    //         break;
+    //     case MULTI_CHANNEL_SIX:
+    //         param.channelLayout = AUDIO_MULTICHANNEL_OUT_5POINT1;
+    //         break;
+    //     case MULTI_CHANNEL_SEVEN:
+    //         param.channelLayout = AUDIO_MULTICHANNEL_OUT_6POINT1;
+    //         break;
+    //     case MULTI_CHANNEL_EIGHT:
+    //         param.channelLayout = AUDIO_MULTICHANNEL_OUT_7POINT1;
+    //         break;
+    //     case MULTI_CHANNEL_TEN:
+    //         param.channelLayout = AUDIO_MULTICHANNEL_OUT_7POINT1POINT2;
+    //         break;
+    //     default:
+    //         AUDIO_ERR_LOG("Unsupported channel");
+    //         break;
+    // }
+    param.channelLayout = attr_.channelLayout;
     param.format = ConvertToHdiFormat(attr_.format);
     param.frameSize = PcmFormatToBits(param.format) * param.channelCount / PCM_8_BIT;
     param.startThreshold = DEEP_BUFFER_RENDER_PERIOD_SIZE / (param.frameSize);
diff --git a/frameworks/native/hdiadapter/sink/offload/offload_audio_renderer_sink.cpp b/frameworks/native/hdiadapter/sink/offload/offload_audio_renderer_sink.cpp
index b0bcfcc3..e3975cf9 100644
--- a/frameworks/native/hdiadapter/sink/offload/offload_audio_renderer_sink.cpp
+++ b/frameworks/native/hdiadapter/sink/offload/offload_audio_renderer_sink.cpp
@@ -479,6 +479,11 @@ int32_t OffloadAudioRendererSinkInner::CreateRender(const struct AudioPort &rend
     InitAttrs(param);
     param.sampleRate = attr_.sampleRate;
     param.channelCount = attr_.channel;
+    if (param.channelCount == MONO) {
+        param.channelLayout = CH_LAYOUT_MONO;
+    } else if (param.channelCount == STEREO) {
+        param.channelLayout = CH_LAYOUT_STEREO;
+    }
     param.format = ConverToHdiFormat(attr_.format);
     param.offloadInfo.format = ConverToHdiFormat(attr_.format);
     param.frameSize = PcmFormatToBits(param.format) * param.channelCount / PCM_8_BIT;
diff --git a/frameworks/native/hdiadapter/sink/primary/audio_renderer_sink.cpp b/frameworks/native/hdiadapter/sink/primary/audio_renderer_sink.cpp
index 12930ca1..ce7c0d01 100644
--- a/frameworks/native/hdiadapter/sink/primary/audio_renderer_sink.cpp
+++ b/frameworks/native/hdiadapter/sink/primary/audio_renderer_sink.cpp
@@ -454,6 +454,11 @@ int32_t AudioRendererSinkInner::CreateRender(const struct AudioPort &renderPort)
     InitAttrs(param);
     param.sampleRate = attr_.sampleRate;
     param.channelCount = attr_.channel;
+    if (param.channelCount == MONO) {
+        param.channelLayout = CH_LAYOUT_MONO;
+    } else if (param.channelCount == STEREO) {
+        param.channelLayout = CH_LAYOUT_STEREO;
+    }
     param.format = ConvertToHdiFormat(attr_.format);
     param.frameSize = PcmFormatToBits(param.format) * param.channelCount / PCM_8_BIT;
     param.startThreshold = DEEP_BUFFER_RENDER_PERIOD_SIZE / (param.frameSize);
diff --git a/frameworks/native/hdiadapter/sink/remote/remote_audio_renderer_sink.cpp b/frameworks/native/hdiadapter/sink/remote/remote_audio_renderer_sink.cpp
index 0edee8f1..5c71db2a 100644
--- a/frameworks/native/hdiadapter/sink/remote/remote_audio_renderer_sink.cpp
+++ b/frameworks/native/hdiadapter/sink/remote/remote_audio_renderer_sink.cpp
@@ -234,6 +234,11 @@ int32_t RemoteAudioRendererSinkInner::CreateRender(const struct AudioPort &rende
     InitAttrs(param);
     param.sampleRate = attr_.sampleRate;
     param.channelCount = attr_.channel;
+    if (param.channelCount == MONO) {
+        param.channelLayout = CH_LAYOUT_MONO;
+    } else if (param.channelCount == STEREO) {
+        param.channelLayout = CH_LAYOUT_STEREO;
+    }
     param.format = ConvertToHdiFormat(attr_.format);
     param.frameSize = PCM_16_BIT * param.channelCount / PCM_8_BIT;
     param.startThreshold = DEEP_BUFFER_RENDER_PERIOD_SIZE / (param.frameSize);
diff --git a/frameworks/native/hdiadapter/sink/remote_fast/remote_fast_audio_renderer_sink.cpp b/frameworks/native/hdiadapter/sink/remote_fast/remote_fast_audio_renderer_sink.cpp
index 9ce3a060..c9c8318b 100644
--- a/frameworks/native/hdiadapter/sink/remote_fast/remote_fast_audio_renderer_sink.cpp
+++ b/frameworks/native/hdiadapter/sink/remote_fast/remote_fast_audio_renderer_sink.cpp
@@ -249,6 +249,11 @@ int32_t RemoteFastAudioRendererSinkInner::CreateRender(const struct AudioPort &r
     InitAttrs(param);
     param.sampleRate = attr_.sampleRate;
     param.channelCount = attr_.channel;
+    if (param.channelCount == MONO) {
+        param.channelLayout = CH_LAYOUT_MONO;
+    } else if (param.channelCount == STEREO) {
+        param.channelLayout = CH_LAYOUT_STEREO;
+    }
     param.format = ConvertToHdiFormat(attr_.format);
     param.frameSize = PCM_16_BIT * param.channelCount / PCM_8_BIT;
     param.startThreshold = DEEP_BUFFER_RENDER_PERIOD_SIZE / (param.frameSize);
diff --git a/frameworks/native/hdiadapter/source/common/i_audio_capturer_source.cpp b/frameworks/native/hdiadapter/source/common/i_audio_capturer_source.cpp
index 26d8a5d0..7cb42cd2 100644
--- a/frameworks/native/hdiadapter/source/common/i_audio_capturer_source.cpp
+++ b/frameworks/native/hdiadapter/source/common/i_audio_capturer_source.cpp
@@ -117,7 +117,7 @@ int32_t IAudioCapturerSourceInit(void *wapper, const SourceAttr *attr)
     iAttr.deviceNetworkId = attr->deviceNetworkId;
     iAttr.deviceType = attr->deviceType;
     iAttr.sourceType = attr->sourceType;
-
+    iAttr.channelLayout = attr->channelLayout;
     ret = iAudioCapturerSource->Init(iAttr);
 
     return ret;
diff --git a/frameworks/native/hdiadapter/source/common/i_audio_capturer_source_intf.h b/frameworks/native/hdiadapter/source/common/i_audio_capturer_source_intf.h
index 4197199a..26e94701 100644
--- a/frameworks/native/hdiadapter/source/common/i_audio_capturer_source_intf.h
+++ b/frameworks/native/hdiadapter/source/common/i_audio_capturer_source_intf.h
@@ -37,6 +37,7 @@ typedef struct {
     const char *deviceNetworkId;
     int32_t deviceType;
     int32_t sourceType;
+    uint64_t channelLayout;
 } SourceAttr;
 
 struct CapturerSourceAdapter {
diff --git a/frameworks/native/hdiadapter/source/fast/fast_audio_capturer_source.cpp b/frameworks/native/hdiadapter/source/fast/fast_audio_capturer_source.cpp
index d5300ef3..b6ad235c 100644
--- a/frameworks/native/hdiadapter/source/fast/fast_audio_capturer_source.cpp
+++ b/frameworks/native/hdiadapter/source/fast/fast_audio_capturer_source.cpp
@@ -246,6 +246,11 @@ int32_t FastAudioCapturerSourceInner::CreateCapture(const struct AudioPort &capt
     param.format = ConvertToHdiFormat(attr_.format);
     param.isBigEndian = attr_.isBigEndian;
     param.channelCount = attr_.channel;
+    if (param.channelCount == MONO) {
+        param.channelLayout = CH_LAYOUT_MONO;
+    } else if (param.channelCount == STEREO) {
+        param.channelLayout = CH_LAYOUT_STEREO;
+    }
     param.silenceThreshold = attr_.bufferSize;
     param.frameSize = param.format * param.channelCount;
     param.startThreshold = 0;
diff --git a/frameworks/native/hdiadapter/source/primary/audio_capturer_source.cpp b/frameworks/native/hdiadapter/source/primary/audio_capturer_source.cpp
index fd0f4bce..1b977cac 100755
--- a/frameworks/native/hdiadapter/source/primary/audio_capturer_source.cpp
+++ b/frameworks/native/hdiadapter/source/primary/audio_capturer_source.cpp
@@ -495,6 +495,11 @@ int32_t AudioCapturerSourceInner::CreateCapture(struct AudioPort &capturePort)
     param.format = ConvertToHdiFormat(attr_.format);
     param.isBigEndian = attr_.isBigEndian;
     param.channelCount = attr_.channel;
+    if (param.channelCount == MONO) {
+        param.channelLayout = CH_LAYOUT_MONO;
+    } else if (param.channelCount == STEREO) {
+        param.channelLayout = CH_LAYOUT_STEREO;
+    }
     param.silenceThreshold = attr_.bufferSize;
     param.frameSize = param.format * param.channelCount;
     param.startThreshold = DEEP_BUFFER_CAPTURE_PERIOD_SIZE / (param.frameSize);
diff --git a/frameworks/native/hdiadapter/source/remote/remote_audio_capturer_source.cpp b/frameworks/native/hdiadapter/source/remote/remote_audio_capturer_source.cpp
index 246e1610..50f5bbaa 100644
--- a/frameworks/native/hdiadapter/source/remote/remote_audio_capturer_source.cpp
+++ b/frameworks/native/hdiadapter/source/remote/remote_audio_capturer_source.cpp
@@ -242,6 +242,11 @@ int32_t RemoteAudioCapturerSourceInner::CreateCapture(struct AudioPort &captureP
     param.format = ConvertToHdiFormat(attr_.format);
     param.isBigEndian = attr_.isBigEndian;
     param.channelCount = attr_.channel;
+    if (param.channelCount == MONO) {
+        param.channelLayout = CH_LAYOUT_MONO;
+    } else if (param.channelCount == STEREO) {
+        param.channelLayout = CH_LAYOUT_STEREO;
+    }
     param.silenceThreshold = attr_.bufferSize;
     param.frameSize = param.format * param.channelCount;
     param.startThreshold = deepBufferCapturePeriodSize / (param.frameSize);
diff --git a/frameworks/native/hdiadapter/source/remote_fast/remote_fast_audio_capturer_source.cpp b/frameworks/native/hdiadapter/source/remote_fast/remote_fast_audio_capturer_source.cpp
index 9db90e47..91352f58 100644
--- a/frameworks/native/hdiadapter/source/remote_fast/remote_fast_audio_capturer_source.cpp
+++ b/frameworks/native/hdiadapter/source/remote_fast/remote_fast_audio_capturer_source.cpp
@@ -260,7 +260,11 @@ int32_t RemoteFastAudioCapturerSourceInner::CreateCapture(const struct AudioPort
     CHECK_AND_RETURN_RET_LOG(audioAdapter_ != nullptr, ERR_INVALID_HANDLE, "CreateCapture: audio adapter is null.");
     struct AudioSampleAttributes param;
     InitAttrs(param);
-
+    if (param.channelCount == MONO) {
+        param.channelLayout = CH_LAYOUT_MONO;
+    } else if (param.channelCount == STEREO) {
+        param.channelLayout = CH_LAYOUT_STEREO;
+    }
     struct AudioDeviceDescriptor deviceDesc;
     deviceDesc.portId = capturePort.portId;
     deviceDesc.pins = PIN_IN_MIC;
diff --git a/frameworks/native/pulseaudio/modules/hdi/hdi_sink.c b/frameworks/native/pulseaudio/modules/hdi/hdi_sink.c
index 6993cf51..eca2ce11 100644
--- a/frameworks/native/pulseaudio/modules/hdi/hdi_sink.c
+++ b/frameworks/native/pulseaudio/modules/hdi/hdi_sink.c
@@ -2038,7 +2038,7 @@ static void StartPrimaryHdiIfRunning(struct Userdata *u)
     }
 }
 
-static void ResetMultiChannelHdiState(struct Userdata *u, int32_t sinkChannels)
+static void ResetMultiChannelHdiState(struct Userdata *u, int32_t sinkChannels, uint64_t sinkChannelLayout)
 {
     if (u->multiChannel.isHDISinkInited) {
         if (u->multiChannel.sample_attrs.channel != sinkChannels) {
@@ -2048,6 +2048,7 @@ static void ResetMultiChannelHdiState(struct Userdata *u, int32_t sinkChannels)
             u->multiChannel.isHDISinkInited = false;
             u->multiChannel.sample_attrs.adapterName = "primary";
             u->multiChannel.sample_attrs.channel = sinkChannels;
+            u->multiChannel.sample_attrs.channelLayout = sinkChannelLayout;
             u->multiChannel.sinkAdapter->RendererSinkInit(u->multiChannel.sinkAdapter, &u->multiChannel.sample_attrs);
             u->multiChannel.isHDISinkInited = true;
         } else {
@@ -2059,6 +2060,7 @@ static void ResetMultiChannelHdiState(struct Userdata *u, int32_t sinkChannels)
     } else {
         u->multiChannel.sample_attrs.adapterName = "primary";
         u->multiChannel.sample_attrs.channel = sinkChannels;
+        u->multiChannel.sample_attrs.channelLayout = sinkChannelLayout;
         u->multiChannel.sinkAdapter->RendererSinkInit(u->multiChannel.sinkAdapter, &u->multiChannel.sample_attrs);
         u->multiChannel.isHDISinkInited = true;
     }
@@ -2081,7 +2083,7 @@ static void StartMultiChannelHdiIfRunning(struct Userdata *u)
     uint64_t sinkChannelLayout = DEFAULT_MULTICHANNEL_CHANNELLAYOUT;
     EffectChainManagerReturnMultiChannelInfo(&sinkChannel, &sinkChannelLayout);
 
-    ResetMultiChannelHdiState(u, sinkChannel);
+    ResetMultiChannelHdiState(u, sinkChannel, sinkChannelLayout);
 }
 
 static void StopPrimaryHdiIfNoRunning(struct Userdata *u)
@@ -2120,7 +2122,7 @@ static void PaInputStateChangeCbMultiChannel(struct Userdata *u, pa_sink_input *
         uint32_t sinkChannel = DEFAULT_MULTICHANNEL_NUM;
         uint64_t sinkChannelLayout = DEFAULT_MULTICHANNEL_CHANNELLAYOUT;
         EffectChainManagerReturnMultiChannelInfo(&sinkChannel, &sinkChannelLayout);
-        ResetMultiChannelHdiState(u, sinkChannel);
+        ResetMultiChannelHdiState(u, sinkChannel, sinkChannelLayout);
     } else if (stopping) {
         // Continuously dropping data clear counter on entering suspended state.
         if (u->bytes_dropped != 0) {
@@ -2971,7 +2973,7 @@ static int32_t SinkSetStateInIoThreadCbStartMultiChannel(struct Userdata *u, pa_
     uint32_t sinkChannel = DEFAULT_MULTICHANNEL_NUM;
     uint64_t sinkChannelLayout = DEFAULT_MULTICHANNEL_CHANNELLAYOUT;
     EffectChainManagerReturnMultiChannelInfo(&sinkChannel, &sinkChannelLayout);
-    ResetMultiChannelHdiState(u, sinkChannel);
+    ResetMultiChannelHdiState(u, sinkChannel, sinkChannelLayout);
     return 0;
 }
 
@@ -3152,6 +3154,7 @@ static int32_t PrepareDeviceMultiChannel(struct Userdata *u, struct RendererSink
     u->multiChannel.sample_attrs.openMicSpeaker = u->open_mic_speaker;
     u->multiChannel.sample_attrs.sampleRate = u->ss.rate;
     u->multiChannel.sample_attrs.channel = DEFAULT_MULTICHANNEL_NUM;
+    u->multiChannel.sample_attrs.channelLayout = DEFAULT_MULTICHANNEL_CHANNELLAYOUT;
     u->multiChannel.sample_attrs.volume = MAX_SINK_VOLUME_LEVEL;
     u->multiChannel.sample_attrs.filePath = filePath;
     u->multiChannel.sample_attrs.deviceNetworkId = u->deviceNetworkId;
